{
    "collab_server" : "",
    "contents" : "#' @title Run class\n#'\n#' @docType class\n#' @importFrom R6 R6Class\n#' @export\n#' @description A class representation of a Bio-Rad plate.\n#'\n#' @format \\code{\\link{Plate}} class generator\n#'\n#' @usage \\code{run <- Run$new(xl_file = '~/Google Drive/spectrum/stats/tarnawski/yafa/data/Heat map results YaFa Explant 1.xlsx')}\n#'\n#' @keywords data\n#'\n\n\n###\n# notes:\n#     - can you steal some stuff from here: http://www.biomedcentral.com/content/pdf/1471-2164-13-296.pdf\n###\n\n\n\nRun <- R6::R6Class(\n  \"Run\",\n  public = list(\n\n    raw_data = NA,\n    quality_data = NA, \n    normalized_data = NA,\n    normalization_method = NA, \n    metadata = NA,\n\n    \n    # public methods\n    initialize = function(xl_file, sheet = 1) {\n\n      if (!missing(xl_file)) {\n        dat <- readxl::read_excel(xl_file, sheet)\n        \n        # find where data is located\n        ct_idx <- which(dat[,1] == 'FAM-MGB Ct')\n        qual_idx <- which(dat[,1] == 'Quality Results')\n        \n        # parse out the ct_values\n        g_start <- ct_idx + 2\n        gene_names <- borgmisc::trim(setNames(unlist(dat[g_start, -c(1,2)]), NULL))\n        sample_names <- borgmisc::trim(setNames(unlist(dat[(g_start + 1):(qual_idx - 1), 2]), NULL))\n        ct_values <- as.matrix(dat[(g_start + 1):(qual_idx - 1), 3:ncol(dat)])\n        ct_values <- apply(ct_values, 2, as.numeric)\n        colnames(ct_values) <- gene_names\n        rownames(ct_values) <- sample_names\n        \n        # parse out the quality data      \n        g_start <- qual_idx + 2\n        s_end <- ((g_start + 1):nrow(dat))[min(which(is.na(dat[(g_start + 1):nrow(dat), 2])))]\n        gene_names <- borgmisc::trim(setNames(unlist(dat[g_start, -c(1,2)]), NULL))\n        sample_names <- borgmisc::trim(setNames(unlist(dat[(g_start + 1):(s_end - 1), 2]), NULL))\n        q_values <- as.matrix(dat[(g_start + 1):(s_end - 1), 3:ncol(dat)])\n        colnames(q_values) <- gene_names\n        rownames(q_values) <- sample_names\n\n        # sanity check\n        all_clear <- all(\n          rownames(ct_values) == rownames(ct_values), \n          colnames(ct_values) == colnames(ct_values)\n          )\n        \n        if (all_clear) {\n          self$raw_data <- ct_values\n          self$quality_data <- q_values\n        } else {\n          stop('There is a problem with the input file... Exiting...')\n        }\n      }\n      \n    },\n    \n    # getting around known issue: https://github.com/wch/R6/issues/51\n    say_hi = function(x) {\n      print('hello')\n    }\n  )\n)\n\n\n\nRun$set(\"public\", \"threshold_data\", function(LOD = 25) {\n\n  # set up our masks\n  lod_mask <- self$raw_data > LOD\n  fail_mask <- self$quality_data == 'Fail'\n  na_mask <- !lod_mask & fail_mask # anything that was detected but was marked as FAIL needs to be NA\n  \n  ct <- self$raw_data\n  ct[lod_mask] <- LOD\n  ct[na_mask] <- NA\n  \n  self$normalized_data <- LOD - ct\n\n})\n\n\n\nRun$set(\"public\", \"merge_tech_reps\", function(na_rm = T) {\n  \n  # create new matrix -- 1 col per gene\n  all_genes <- unique(colnames(self$normalized_data))\n  new_dat <- matrix(NA, ncol = length(all_genes), nrow = nrow(self$normalized_data))\n  rownames(new_dat) <- rownames(self$normalized_data)\n  colnames(new_dat) <- all_genes\n  \n  # average across plate replicates\n  for (i in seq_along(all_genes)) {\n    sel <- which(colnames(self$normalized_data) == all_genes[i])\n    \n    if (length(sel) > 1) {\n      to_ave <- self$normalized_data[,sel]\n      meaners <- apply(to_ave, 1, mean, na.rm = na_rm)\n    } else {\n      meaners <- self$normalized_data[,sel]\n    }\n    new_dat[ ,all_genes[i]] <- meaners\n  }\n  \n  self$normalized_data <- new_dat\n  \n})\n\n\n",
    "created" : 1449154177754.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "300266883",
    "id" : "30218C8E",
    "lastKnownWriteTime" : 1461764446,
    "last_content_update" : 1461764446253,
    "path" : "~/Google Drive/spectrum/packages/sspcR/R/Run.R",
    "project_path" : "R/Run.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}